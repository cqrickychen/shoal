
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
 #
 # Copyright 1997-2010 Sun Microsystems, Inc. All rights reserved.
 #
 # The contents of this file are subject to the terms of either the GNU
 # General Public License Version 2 only ("GPL") or the Common Development
 # and Distribution License("CDDL") (collectively, the "License").  You
 # may not use this file except in compliance with the License. You can obtain
 # a copy of the License at https://glassfish.dev.java.net/public/CDDL+GPL.html
 # or glassfish/bootstrap/legal/LICENSE.txt.  See the License for the specific
 # language governing permissions and limitations under the License.
 #
 # When distributing the software, include this License Header Notice in each
 # file and include the License file at glassfish/bootstrap/legal/LICENSE.txt.
 # Sun designates this particular file as subject to the "Classpath" exception
 # as provided by Sun in the GPL Version 2 section of the License file that
 # accompanied this code.  If applicable, add the following below the License
 # Header, with the fields enclosed by brackets [] replaced by your own
 # identifying information: "Portions Copyrighted [year]
 # [name of copyright owner]"
 #
 # Contributor(s):
 #
 # If you wish your version of this file to be governed by only the CDDL or
 # only the GPL Version 2, indicate your decision by adding "[Contributor]
 # elects to include this software in this distribution under the [CDDL or GPL
 # Version 2] license."  If you don't indicate a single choice of license, a
 # recipient has the option to distribute your version of this file under
 # either the CDDL, the GPL Version 2 or to extend the choice of license to
 # its licensees as provided above.  However, if you add GPL Version 2 code
 # and therefore, elected the GPL Version 2 license, then the option applies
 # only if the new code is made subject to such option by the copyright
 # holder.



#used for GMS_LOGGER
no.instance.dsc=Could not get an instance of Distributed State Cache to fetch member details for {0}
gms.init=Initialized Group Communication System....
failurenotificationsignals.send.member=Sending FailureNotificationSignals to registered Actions. Member: {0}...
failurenotificationsignals.send.component=Sending FailureRecoveryNotification to component {0}
failuresuspectedsignals.send.member=Sending FailureSuspectedSignals to registered Actions. Member:{0}...
action.exception=ActionException : {0}
gms.failureSuspectedEventReceived=Received FailureSuspectedEvent for Member: {0} of Group: {1}
plannedshutdownsignals.send.member=Sending PlannedShutdownSignals to registered Actions for shutdownType {0} Member: {1}...
shutdown.groupshutdown=Leaving GMS group {0} with shutdown type set to GroupShutdown
shutdown.instanceshutdown=Leaving GMS group {0} with shutdown type set to InstanceShutdown
interruptedException.occurred.put.eventpacket=InteruptedException occurred when putting EventPacket into viewQueue: {0}
starting.cluster=Starting ClusterManager...
ioexception.occurred.cluster.shutdown=IOException occured while announcing cluster shutdown : {0}
interruptedException.occurred.add.message=Interrupted Exception occured while adding message to Shoal MessageQueue:{0}
member.groupshutdown=Received Group Shutting down message from member : {0} of Group: {1}
membership.snapshot.analysis=Analyzing new membership snapshot received as part of event : {0} for Member: {1} of Group: {2}
plannedshutdownevent.announcement=Received PlannedShutdownEvent Announcement from Instance {0} with Shutdown type = {1} of Group: {2}
systemadv.not.contain.customtag=The SystemAdvertisement did not contain the custom tag value : {0}
member.failed=The following member has failed: {0} of Group: {1}
event.message=Event : {0}
peer.involved=Peer Involved : {0}
view.message=View : {0}
rejoin.subevent.replaced=Replaced rejoin subevent for member name '{0}' with '{1}'
viewwindow.adding.join.member=Adding Join member: {0} group: {1} StartupState:{2} {3}
viewwindow.adding.joined.ready.member=Adding Joined And Ready member : {0} Group: :{1} StartupState:{2} {3}
viewwindow.rejoining=rejoining: missed reporting past FAILURE of this instance that had joined the group at \
mgmt.clustermanager.send.failed=ClusterManager.send: message {0} not sent to {1}\
mgmt.clustermanager.send.membernotinview=ClusterManager.send : Cluster View does not contain member {0} hence will not send message.
mgmt.clustermanager.broadcast.failed=ClusterManager.send: broadcast of message {0} failed
mgmt.clustermanager.nullmessage= ClusterManger.receiveMessageEvent: Received a null message
mgmt.unknownMessage=Received an unknown message
mgmt.clustermanager.invalidbindinterfaceaddress=invalid bindInterfaceEndpointAddress computed from property {0} value={1}
mgmt.clusterviewmanager.skipnotify=no changes from previous view, skipping notification of listeners for cluster view event {0} from member: {1} group: {2}
mgmt.healthmonitor.lwrmulticastioexception=Could not instantiate LWRMulticast : {0}
mgmt.healthmonitor.processmemberstatequery=processMemberStateQuery failed to send memberStateResponse msg to {0}" send returned false
mgmt.healthmonitor.invalidquery=ignoring memberstatequery. SysAdv is null
mgmt.healthmonitor.lwrmulticast.send.failed=Could not send the message via LWRMulticast : {0}
mgmt.healthmonitor.nosenderadv=ignoring memberStateResponse, received a memberstateresponse with no sender advertisement
mgmt.healthmonitor.watchdog=WATCHDOG notification for member name:{0} id: {1} from watchdog:{2} wasMaster: {3}
mgmt.heatlhmonitor.ready=Calling reportMyState() with READY...
mgmt.healthmonitor.alreadydead=assignAndReportFailure already called for member {0} ignoring this invocation since member already declared DEAD {1}
mgmt.healthmonitor.reportstatefailed=failed to send heartbeatmessage with state={0} to {1}. Reason: {2}
mgmt.healthmonitor.reportotherstatefailed=send failed to report member {0} state={1} to group: {2}. Reason: {3}
mgmt.healthmonitor.threaduncaughtexception=Uncaught Throwable in healthMonitorThread {0}:{1}
mgmt.healthmonitor.timestampconversionexception=Exception occurred during time stamp conversion : {0}
mgmt.healthmonitor.removemasteradvfail= {0} peer: {1} does not exist in local ClusterView
mgmt.heatlhmonitor.failedwatchdognotify=broadcast send returned false. failed WATCHDOG notification of failed member {0} to group {1}. Reason: {2}
mgmt.masternode.missingna=Missing NODEADV message element. message = {0}
mgmt.masternode.noview=New View Received without corresponding ViewChangeEvent details
mgmt.masternode.staleview=Received an older clusterView sequence {0} of size :{1} Current sequence :{2} discarding out of sequence view.
mgmt.masternode.staleviewnotify=Received a stale clusterview, older clusterview sequence {0}. Current sequence :{1} discarding out of sequence view.  Notified listeners of ChangeEvent={2} from {3} for group: {4}
mgmt.masternode.unreportedmasterfailure=Previously elected Master node {0} has restarted. There was no failure notification sent out for it.
mgmt.masternode.restarted=Instance {0} was restarted at {1,time,full} on {1,date}.
mgmt.masternode.nofailurereported=Note that there was no Failure notification sent out for this instance that was previously started at {0,time,full} on {0,date}
mgmt.masternode.dupmasternodemsg=receiveMessageEvent: ignored duplicate master node message masterViewSeqId:{0} from member:{1} message={2}
mgmt.masternode.nullmessage=Received a null message
mgmt.masternode.announcemasternode=Announcing Master Node designation for member: {1} of group: {2}. Local view contains {0} entries
mgmt.masternode.assumingmasternode=Assuming Master Node designation member:{0} for group:{1}
mgmt.masternode.sendmsgfailed=send unexpectedly returned false sending messge {0} to instance {1}
mgmt.masternode.broadcastmsgfailed=send unexpectedly returned false broadcasting messge {0} to cluster {1}
mgmt.masternode.registeredlistener=MasterNode message listener is registered for member: {0} group: {1}
mgmt.masternode.groupstartcomplete=GroupStart for group: {0} State: {1} {2}
mgmt.masternode.missgroupstartupcomplete=missed GroupStartupComplete message. Timed out group startup after {0} secs
mgmt.masternode.processmsgexception=MasterNode.ProcessOutstandingMessages.run: ignoring exception {0}
mgmt.masternode.processmsgcompleted=Completed processing outstanding master node messages for member:{0} group:{1} outstandingMessages to process:{2}
grizzlynetmgr.invalidmcastaddr=invalid multicast address: {0} defaulting to {1}. Valid multicast address is a Class D IP address in the range 224.0.0.0-239.255.255.255 inclusive. Address 224.0.0.0 is reserved and should not be used.
grizzlynetmgr.invalidbindaddr=GrizzlyNetworkManager.configure: unable to configure NetworkInterfaceName due to {0}     
absnetmgr.beforefailed=failed to execute beforeDispatchingMessage()
absnetmgr.afterfailed=failed to execute afterDispatchingMessage()
absnetmgr.receivemsg=failed to receive a message: type = {0}
blockingiomcast.damaged=damaged multicast packet discarded
blockingiomcast.failprocessing=failed to process a received message={0}
blockingiomcast.exceedsmaxsize=Multicast datagram of size {0} exceeds max multicast size {1}
blockingiomcast.mcastreceivefailure=failure during multicast receive {0}
blockingiomcast.receiveprocess.uncaughtthrowable=Uncaught Throwable {0} in thread {1}
blockingiomcast.fail.set.timetolive=unable to set multicast socket timeToLive to {0}
messageImpl.msg.too.big=total message size is too big: size = {0}, max size = {1}
netutil.deserialize.failure=NetworkUtility.deserialized current objects: messages={0} failed while deserializing name={1}
netutil.no.available.ports=Fatal error. No available ports exist for {0} in range {1} to {2}
dsc.no.ctx=Can not find GMSContext for group: {0}
dsc.sync.exception=GMSException during DistributedStateCache Sync....
dsc.send.failed=DistributedStateCacheImpl.sendMessage failed to member:{0}  message:{1}
gmsctx.assume.groupleader="Assuming group leadership to shutdown group: {0}
group.handle.sendmessage.failed=GroupHandleImpl.sendMesage: could not send message {0} for component {1} to member {2} exception:{3}
gh.dsc.force.sync.failed=Force Syncing of DistributedStateCache failed: {0}
msg.wdw.thread.shutdown=MessageWindow thread for group {0} terminated due to shutdown notification with {1} unprocessed messages
msg.wdw.exception.processing.msg=ignoring exception during message window processing
msg.wdw.thread.terminated=MessageWindow thread for group {0} terminated due to shutdown notification
util.sysadv.missing.custom.tag=Missing expected tag name:{0} in SystemAdvertisement for member:{1}. Defaulting value to null.
view.window.eventhandler.exception=handled exception processing event packet {0}
view.window.thread.terminated=View Window event processing thread for group {0} terminated normally
view.window.view.change=GMS View Change Received for group {0} : Members in view for {1}(before change analysis) are :\n{2}
view.window.groupleader.notify=adding GroupLeadershipNotification signal leaderMember: {0} of group: {1}
msg.action.unhandled.exception=handled unexpected exception {0} when calling registered application callback method {1}.processNotification.  The method should have handled this exception.
gms.join=Member {0} is joining group {1} ...
gms.leave=Member {0} is leaving group {1}
gms.group.shutdown=GMS:Announcing GroupShutdown to group {0} with State = {1}
gms.group.startup=GMS:Announcing GroupStartup[{0}] for Group:{1} Members: {2}
gms.ready="GMS:Reporting Joined and Ready state to group {0}
recovery.selector.invalid.mode=resolveRecoveryTarget() returning false due to unimplemented RecoverySelectorMode:{0} for failed member:{1} group:{2}
recovery.selector.failed=RecoveryTargetSelection:Chronological Successor algorithm failed to select a recovery member for failed member{0} revert to selecting first member in view as RecoveryTarget. view prior to reported failure: {1}
recovery.selector.appointed=Appointed Recovery Server:{0}:for failed member:{1}:for group:{2}
router.msg.handler.exception=handled unexpected exception {0} processing message signal {1}
router.shutdown.unprocessed=shutdown: cleared queue with {0} unprocessed events
router.shutdown.unprocessed.signal=shutdown: unprocessed signal:{0}
sig.handler.unhandled= exiting due unhandled exception in thread {0}
sig.handler.thread.terminated=SignalHandler task named {0} exiting
sig.handler.ignoring.exception=Ignoring exception while running action handler. Handler should have handled following unchecked exception {0}



